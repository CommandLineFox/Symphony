{"version":3,"file":"ConfigHandler.js","sourceRoot":"","sources":["ConfigHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\r\n\r\ninterface IFunctionBase <T> {\r\n    (value: any, key: string): boolean | string[];\r\n    readonly trueName: string,\r\n}\r\n\r\nexport interface IFunction <T> extends IFunctionBase <T> {\r\n    readonly defaultValue: T;\r\n}\r\n\r\nexport type IFunctionType <T> = T extends IFunction <infer U> ? U : never;\r\n\r\nfunction createBaseType <T> (trueName: string, check: (value: any, key: string) => boolean | string[]): IFunctionBase <T> {\r\n    function temp(value: any, key: string) {\r\n        return check(value, key)\r\n    }\r\n    temp.trueName = trueName;\r\n    return temp;\r\n}\r\n\r\nfunction createType <T> (trueName: string, defaultValue: T, check: (value: any, key: string) => boolean | string[]): IFunction <T> {\r\n    const temp = createBaseType(trueName, check) as any;\r\n    temp.defaultValue = defaultValue;\r\n    return temp;\r\n}\r\n\r\nfunction checkObject(object: { [key: string]: any }, template: { [key: string]: IFunction <any> }, name = \"\") {\r\n    const errors = [];\r\n\r\n    for (const key in template) {\r\n        const check = template[key];\r\n\r\n        const result = check(object[key], name + key);\r\n        if (result instanceof Array) {\r\n            errors.push(...result);\r\n        }\r\n        else if (!result) {\r\n            if (object[key] === undefined) {\r\n                errors.push(`${name}${key} does not not exists and must have the type of ${template[key].trueName}`);\r\n            }\r\n            else {\r\n                errors.push(`${name}${key} must be the type of ${template[key].trueName}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    return errors;\r\n}\r\n\r\nexport const base = {\r\n    boolean: createBaseType(\"Boolean\", (value: any) => typeof value === \"boolean\"),\r\n    number: createBaseType(\"Number\", (value: any) => typeof value === \"number\"),\r\n    string: createBaseType(\"String\", (value: any) => typeof value === \"string\"),\r\n}\r\n\r\nexport function boolean(defaultValue: boolean) {\r\n    return createType(base.boolean.trueName, defaultValue, base.boolean);\r\n}\r\n\r\nexport function number(defaultValue: number) {\r\n    return createType(base.number.trueName, defaultValue, base.number);\r\n}\r\n\r\nexport function string(defaultValue: string) {\r\n    return createType(base.string.trueName, defaultValue, base.string);\r\n}\r\n\r\nexport function optional <T> (type: IFunctionBase <T> , defaultValue ? : T | null) {\r\n    return createType(type.trueName + \"?\", defaultValue, (value: any, key: string) => value === undefined || value === null || type(value, key));\r\n}\r\n\r\nexport function array <T> (type: IFunctionBase <T> , defaultValue: T[] = []) {\r\n    return createType(type.trueName + \"[]\", defaultValue, (value: any, key: string) => value instanceof Array && value.every((it) => type(it, key) === true));\r\n}\r\n\r\nexport function object(template: { [key: string]: IFunction <any> }) {\r\n    const defaultValue: {\r\n        [key: string]: any\r\n    } = {};\r\n\r\n    for (const key in template) {\r\n        defaultValue[key] = template[key].defaultValue;\r\n    }\r\n\r\n    return createType(\"Object\", defaultValue, (value: any, key ? : string) => {\r\n        if (typeof value === \"object\") {\r\n            const errors = checkObject(value, template, key + \".\");\r\n            if (errors.length === 0) {\r\n                return true\r\n            }\r\n            else {\r\n                return errors;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    })\r\n}\r\n\r\nexport function generateConfig(file: string, template: { [key: string]: IFunction <any> }) {\r\n    const config: {\r\n        [key: string]: any\r\n    } = {};\r\n\r\n    for (const key in template) {\r\n        config[key] = template[key].defaultValue;\r\n    }\r\n\r\n    fs.writeFileSync(file, JSON.stringify(config));\r\n}\r\n\r\nexport function getConfig <T extends { [key: string]: IFunction <any> }> (file: string, template: T) {\r\n    const config = JSON.parse(fs.readFileSync(file).toString());\r\n    const errors = checkObject(config, template);\r\n\r\n    if (errors.length === 0) {\r\n        return config as { [key in keyof T]: IFunctionType <T[key]> }\r\n    }\r\n    else {\r\n        errors.forEach((error) => console.error(error));\r\n        return undefined;\r\n    }\r\n}"]}